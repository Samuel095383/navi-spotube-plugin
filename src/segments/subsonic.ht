import "module:std" as std

var HttpClient = std.HttpClient
var HttpBaseOptions = std.HttpBaseOptions

/// Subsonic/Navidrome API client.
///
/// Authentication uses the Subsonic "enc:" password format:
///   p=enc:<hex-encoded-password>
/// This avoids transmitting the password in plain text in query parameters.
/// For maximum security, always access your Navidrome server over HTTPS.
class SubsonicClient {
  final baseUrl: string
  final username: string
  final password: string

  var _api: HttpClient
  var _encPassword: string

  static final API_VERSION = "1.16.1"
  static final CLIENT_NAME = "navi-spotube"

  construct (this.baseUrl, this.username, this.password) {
    _api = HttpClient(
      HttpBaseOptions(
        baseUrl: "${baseUrl}/rest"
      )
    )
    _encPassword = "enc:${_hexEncode(password)}"
  }

  /// Hex-encodes a string for use in the Subsonic "enc:" password format.
  /// Note: only ASCII characters (code < 128) are reliably supported by all
  /// Subsonic servers. Most passwords use only ASCII characters.
  fun _hexEncode(s: string) -> string {
    var result = ""
    final hexChars = "0123456789abcdef"
    for (var i = 0; i < s.length; i++) {
      var code = s.codeUnitAt(i)
      var hi = (code ~/ 16) % 16
      var lo = code % 16
      result = result + hexChars[hi] + hexChars[lo]
    }
    return result
  }

  /// Builds a direct stream URL for a given Subsonic song ID.
  /// No transcoding is applied â€“ the file is served in its original format.
  fun streamUrl(songId: string) -> string {
    return "${baseUrl}/rest/stream.view?id=${songId}&u=${username}&p=${_encPassword}&v=${API_VERSION}&c=${CLIENT_NAME}"
  }

  /// Builds a transcoded stream URL with the specified format and max bitrate (kbps).
  fun streamUrlTranscoded(songId: string, format: string, maxBitRate: int) -> string {
    return "${baseUrl}/rest/stream.view?id=${songId}&u=${username}&p=${_encPassword}&v=${API_VERSION}&c=${CLIENT_NAME}&format=${format}&maxBitRate=${maxBitRate}"
  }

  /// Builds a cover art URL for the given Subsonic cover art ID.
  fun coverArtUrl(coverArtId: string) -> string {
    return "${baseUrl}/rest/getCoverArt.view?id=${coverArtId}&u=${username}&p=${_encPassword}&v=${API_VERSION}&c=${CLIENT_NAME}&size=300"
  }

  /// Sends a ping to verify the server connection and credentials.
  /// Returns the raw HTTP response whose `.data["subsonic-response"]["status"]`
  /// will be "ok" on success.
  fun ping() -> Future {
    return _api.get_req(
      "/ping.view",
      queryParameters: {
        "u": username,
        "p": _encPassword,
        "v": API_VERSION,
        "c": CLIENT_NAME,
        "f": "json"
      }.toJson()
    )
  }

  /// Searches for songs using the Subsonic search3 endpoint.
  fun search(query: string, songCount: int) -> Future {
    return _api.get_req(
      "/search3.view",
      queryParameters: {
        "u": username,
        "p": _encPassword,
        "v": API_VERSION,
        "c": CLIENT_NAME,
        "f": "json",
        "query": query,
        "songCount": songCount.toString(),
        "albumCount": "0",
        "artistCount": "0"
      }.toJson()
    )
  }
}

export { SubsonicClient }
